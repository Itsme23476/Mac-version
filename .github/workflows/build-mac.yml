name: Build macOS App

on:
  release:
    types: [created]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version number (e.g., 1.9.0)'
        required: false
        default: ''

# Grant write permissions for uploading to releases
permissions:
  contents: write

jobs:
  build-macos:
    runs-on: macos-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pyinstaller
          pip install -r ai_file_organizer/requirements.txt
      
      - name: Get version
        id: version
        run: |
          if [ -n "${{ github.event.inputs.version }}" ]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [ -n "${{ github.event.release.tag_name }}" ]; then
            VERSION="${{ github.event.release.tag_name }}"
            # Remove 'v' or 'V' prefix and any leading dots
            VERSION=$(echo "$VERSION" | sed 's/^[vV]//; s/^\.//')
          else
            # Use sed instead of grep -P (macOS compatible)
            VERSION=$(sed -n 's/.*VERSION = "\([^"]*\)".*/\1/p' ai_file_organizer/app/version.py | head -1)
            if [ -z "$VERSION" ]; then
              VERSION="1.0.0"
            fi
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"
      
      - name: Update version.py with release version
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          echo "Updating version.py to version: $VERSION"
          
          # Update VERSION in version.py
          sed -i '' "s/^VERSION = .*/VERSION = \"$VERSION\"/" ai_file_organizer/app/version.py
          
          # Update BUILD_DATE
          BUILD_DATE=$(date +%Y-%m-%d)
          sed -i '' "s/^BUILD_DATE = .*/BUILD_DATE = \"$BUILD_DATE\"/" ai_file_organizer/app/version.py
          
          # Verify the update
          echo "Updated version.py:"
          cat ai_file_organizer/app/version.py
      
      - name: Build with PyInstaller
        run: |
          cd ${{ github.workspace }}
          python -m PyInstaller --clean --noconfirm Lumina.spec
      
      - name: Verify build
        run: |
          if [ ! -d "dist/Lumina.app" ]; then
            echo "Error: Lumina.app was not created"
            ls -la dist/ || echo "dist folder doesn't exist"
            exit 1
          fi
          echo "Build successful!"
          du -sh dist/Lumina.app
      
      - name: Import Apple Certificate
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
          
          # Decode certificate
          echo "Decoding certificate..."
          echo "$APPLE_CERTIFICATE_BASE64" | base64 --decode > $RUNNER_TEMP/certificate.p12
          
          # Verify the file was created and has content
          if [ ! -s $RUNNER_TEMP/certificate.p12 ]; then
            echo "ERROR: Certificate file is empty. Check APPLE_CERTIFICATE_BASE64 secret."
            exit 1
          fi
          echo "Certificate file size: $(wc -c < $RUNNER_TEMP/certificate.p12) bytes"
          
          # Create and configure keychain
          echo "Creating keychain..."
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          
          # Import certificate
          echo "Importing certificate..."
          security import $RUNNER_TEMP/certificate.p12 -P "$APPLE_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH || {
            echo "ERROR: Failed to import certificate. Check APPLE_CERTIFICATE_PASSWORD secret."
            exit 1
          }
          
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH
          
          # List ALL certificates in keychain (for debugging)
          echo "=== All certificates in keychain ==="
          security find-identity -v $KEYCHAIN_PATH
          
          echo "=== Codesigning certificates ==="
          security find-identity -v -p codesigning $KEYCHAIN_PATH
          
          # Find and save the certificate name
          CERT_NAME=$(security find-identity -v -p codesigning $KEYCHAIN_PATH | grep "Developer ID Application" | head -1 | sed 's/.*"\(.*\)".*/\1/')
          
          if [ -z "$CERT_NAME" ]; then
            echo "WARNING: No 'Developer ID Application' certificate found."
            echo "Looking for any valid signing identity..."
            CERT_NAME=$(security find-identity -v -p codesigning $KEYCHAIN_PATH | grep -v "^$" | head -1 | sed 's/.*"\(.*\)".*/\1/')
          fi
          
          if [ -z "$CERT_NAME" ]; then
            echo "ERROR: No valid code signing certificate found in the keychain."
            echo "Make sure you exported a 'Developer ID Application' certificate as .p12"
            exit 1
          fi
          
          echo "Found certificate: $CERT_NAME"
          
          # Save for later steps
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "CERT_NAME=$CERT_NAME" >> $GITHUB_ENV
      
      - name: Sign Application
        run: |
          echo "Signing with certificate: $CERT_NAME"
          
          if [ -z "$CERT_NAME" ]; then
            echo "ERROR: CERT_NAME is empty"
            exit 1
          fi
          
          # Sign all nested code first
          echo "Signing nested components..."
          find dist/Lumina.app/Contents -type f \( -name "*.dylib" -o -name "*.so" \) -exec \
            codesign --force --options runtime --timestamp --sign "$CERT_NAME" {} \; 2>/dev/null || true
          
          # Sign frameworks
          find dist/Lumina.app/Contents/Frameworks -type d -name "*.framework" 2>/dev/null | while read fw; do
            echo "Signing framework: $fw"
            codesign --force --options runtime --timestamp --sign "$CERT_NAME" "$fw" || true
          done
          
          # Sign the main executable
          echo "Signing main executable..."
          codesign --force --options runtime --timestamp --sign "$CERT_NAME" "dist/Lumina.app/Contents/MacOS/Lumina"
          
          # Sign the entire app bundle
          echo "Signing app bundle..."
          codesign --force --deep --options runtime --timestamp --sign "$CERT_NAME" \
            --entitlements build/entitlements.plist \
            "dist/Lumina.app"
          
          # Verify signature
          echo "Verifying signature..."
          codesign --verify --verbose=2 dist/Lumina.app
          echo "Signature verification complete"
      
      - name: Create DMG
        run: |
          # Install create-dmg
          brew install create-dmg || true
          
          VERSION="${{ steps.version.outputs.version }}"
          DMG_NAME="Lumina-${VERSION}-mac"
          
          # Create DMG
          create-dmg \
            --volname "Lumina $VERSION" \
            --volicon "ai_file_organizer/resources/icon.icns" \
            --window-pos 200 120 \
            --window-size 600 400 \
            --icon-size 100 \
            --icon "Lumina.app" 150 190 \
            --hide-extension "Lumina.app" \
            --app-drop-link 450 185 \
            "dist/${DMG_NAME}.dmg" \
            "dist/Lumina.app" || {
              # Fallback to hdiutil if create-dmg fails
              echo "create-dmg failed, using hdiutil..."
              mkdir -p dist/dmg_temp
              cp -R dist/Lumina.app dist/dmg_temp/
              ln -s /Applications dist/dmg_temp/Applications
              hdiutil create -volname "Lumina $VERSION" \
                -srcfolder dist/dmg_temp \
                -ov -format UDZO \
                "dist/${DMG_NAME}.dmg"
              rm -rf dist/dmg_temp
            }
          
          echo "DMG created:"
          ls -la dist/*.dmg
      
      - name: Sign DMG
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          DMG_PATH="dist/Lumina-${VERSION}-mac.dmg"
          
          echo "Signing DMG with: $CERT_NAME"
          codesign --force --sign "$CERT_NAME" "$DMG_PATH"
          
          echo "DMG signed successfully"
      
      - name: Notarize App
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          DMG_PATH="dist/Lumina-${VERSION}-mac.dmg"
          
          echo "Submitting for notarization..."
          xcrun notarytool submit "$DMG_PATH" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_ID_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait \
            --timeout 30m
          
          echo "Notarization complete!"
      
      - name: Staple Notarization Ticket
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          DMG_PATH="dist/Lumina-${VERSION}-mac.dmg"
          
          echo "Stapling notarization ticket..."
          xcrun stapler staple "$DMG_PATH"
          
          echo "Verifying stapled DMG..."
          spctl --assess --verbose=4 --type open --context context:primary-signature "$DMG_PATH"
          
          echo "DMG is signed, notarized, and ready for distribution!"
      
      - name: Upload DMG Artifact
        uses: actions/upload-artifact@v4
        with:
          name: Lumina-mac-dmg
          path: dist/*.dmg
          retention-days: 30
      
      - name: Upload to Release
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v2
        with:
          files: dist/*.dmg
      
      - name: Update Supabase app_version
        if: github.event_name == 'release'
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG_NAME="${{ github.event.release.tag_name }}"
          RELEASE_NAME="${{ github.event.release.name }}"
          DMG_URL="https://github.com/${{ github.repository }}/releases/download/${TAG_NAME}/Lumina-${VERSION}-mac.dmg"
          PLATFORM="mac"
          
          echo "Updating Supabase with Mac release..."
          echo "Version: ${VERSION}"
          echo "Platform: ${PLATFORM}"
          echo "DMG URL: ${DMG_URL}"
          
          # Check if this version for this platform already exists
          EXISTING=$(curl -s "${SUPABASE_URL}/rest/v1/app_version?version=eq.${VERSION}&platform=eq.${PLATFORM}" \
            -H "apikey: ${SUPABASE_SERVICE_KEY}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_KEY}")
          
          if [ "$EXISTING" = "[]" ]; then
            # Insert new version for Mac platform
            echo "Inserting new Mac version record..."
            curl -X POST "${SUPABASE_URL}/rest/v1/app_version" \
              -H "apikey: ${SUPABASE_SERVICE_KEY}" \
              -H "Authorization: Bearer ${SUPABASE_SERVICE_KEY}" \
              -H "Content-Type: application/json" \
              -d "{
                \"version\": \"${VERSION}\",
                \"platform\": \"${PLATFORM}\",
                \"download_url\": \"${DMG_URL}\",
                \"download_url_mac\": \"${DMG_URL}\",
                \"release_name\": \"${RELEASE_NAME:-Lumina ${VERSION}}\",
                \"release_notes\": \"macOS release ${VERSION}\",
                \"published_at\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",
                \"is_required\": false
              }"
          else
            # Update existing Mac version record
            echo "Updating existing Mac version record..."
            curl -X PATCH "${SUPABASE_URL}/rest/v1/app_version?version=eq.${VERSION}&platform=eq.${PLATFORM}" \
              -H "apikey: ${SUPABASE_SERVICE_KEY}" \
              -H "Authorization: Bearer ${SUPABASE_SERVICE_KEY}" \
              -H "Content-Type: application/json" \
              -d "{
                \"download_url_mac\": \"${DMG_URL}\",
                \"published_at\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
              }"
          fi
          
          echo "Supabase update complete!"
